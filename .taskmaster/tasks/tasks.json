{
   "master": {
      "tasks": [
         {
            "id": 1,
            "title": "Project Setup and Configuration",
            "description": "Initialize the project repository with React, TypeScript, Vite, and configure essential dependencies.",
            "details": "1. Create a new Vite project with React and TypeScript template: `npm create vite@latest smartrecipe -- --template react-ts`\n2. Install core dependencies:\n   - `npm install react-router-dom tailwindcss postcss autoprefixer @radix-ui/react-*`\n   - `npm install lucide-react react-hook-form zod date-fns clsx tailwind-merge`\n   - `npm install @supabase/supabase-js`\n3. Install dev dependencies: `npm install -D typescript @types/react @types/react-dom`\n4. Initialize Tailwind CSS: `npx tailwindcss init -p`\n5. Configure Tailwind CSS in `tailwind.config.js` and create base CSS file\n6. Set up Shadcn/ui components following their installation guide\n7. Create project structure with folders for components, hooks, pages, utils, types, and contexts\n8. Configure ESLint and Prettier for code quality\n9. Set up basic Vite configuration in `vite.config.ts`\n10. Create initial README.md with project overview and setup instructions",
            "testStrategy": "Verify project builds successfully with `npm run build`. Ensure all dependencies are correctly installed and the development server runs with `npm run dev`. Check that Tailwind CSS is properly configured by testing a simple styled component.",
            "priority": "high",
            "dependencies": [],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 2,
            "title": "Supabase Backend Setup",
            "description": "Set up Supabase project, configure database tables, and implement Row Level Security (RLS) policies.",
            "details": "1. Create a new Supabase project from the dashboard\n2. Define and create the following database tables:\n   - users (extends auth.users): profile_id, dietary_restrictions, allergies, skill_level, measurement_system\n   - pantry_items: id, user_id, name, quantity, unit, category, expiration_date, notes, created_at, updated_at\n   - recipes: id, title, description, ingredients, instructions, cooking_time, difficulty, image_url, tags\n   - user_recipes: user_id, recipe_id, is_favorite, notes\n   - shopping_lists: id, user_id, name, created_at\n   - shopping_list_items: id, list_id, name, quantity, unit, category, is_purchased\n3. Set up foreign key relationships between tables\n4. Implement Row Level Security (RLS) policies for each table to ensure users can only access their own data\n5. Create database indexes for frequently queried columns\n6. Set up Supabase Auth settings and enable email authentication\n7. Configure Supabase environment variables in the frontend project\n8. Create a Supabase client utility in the frontend codebase",
            "testStrategy": "Test database schema by inserting and querying sample data. Verify RLS policies by attempting to access data across different user contexts. Ensure foreign key constraints work properly. Test Supabase client connection from the frontend.",
            "priority": "high",
            "dependencies": [1],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 3,
            "title": "Authentication System Implementation",
            "description": "Implement user registration, login, and protected routes using Supabase Auth.",
            "details": "1. Create an AuthContext using React Context API to manage authentication state\n2. Implement the following components:\n   - SignUp: Email/password registration form with validation\n   - Login: Email/password login form with validation\n   - PasswordReset: Form for requesting password reset\n   - AuthGuard: HOC to protect routes requiring authentication\n3. Set up authentication routes in React Router:\n   - /auth/signup\n   - /auth/login\n   - /auth/reset-password\n4. Implement session persistence using Supabase's session management\n5. Create custom hooks:\n   - useAuth: Provides authentication methods and user state\n   - useRequireAuth: Redirects unauthenticated users\n6. Add loading states and error handling for auth operations\n7. Implement logout functionality\n8. Set up route redirection based on authentication status\n9. Store JWT securely and handle token refresh",
            "testStrategy": "Test user registration with valid and invalid inputs. Verify login functionality and session persistence. Test protected routes to ensure they redirect unauthenticated users. Verify password reset flow. Test token refresh mechanism.",
            "priority": "high",
            "dependencies": [1, 2],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 4,
            "title": "User Profile Management",
            "description": "Create user profile management interface for personal details, dietary restrictions, allergies, cooking skill level, and kitchen equipment.",
            "details": "1. Create a UserProfileContext to manage profile state\n2. Design and implement profile management components:\n   - ProfileForm: Form for editing user details\n   - DietaryPreferences: Multi-select component for dietary restrictions\n   - AllergiesInput: Tag-based input for allergies\n   - SkillLevelSelector: Radio button group for cooking skill level\n   - KitchenEquipmentInventory: Checklist for available equipment\n3. Implement form validation using Zod and React Hook Form\n4. Create database functions to update user profile data\n5. Add profile image upload using Supabase Storage\n6. Implement settings for measurement system preference (metric/imperial)\n7. Create a profile completion indicator\n8. Add form submission handling with loading states and error feedback\n9. Implement profile data persistence in Supabase",
            "testStrategy": "Test profile form submission with various inputs. Verify data persistence in the database. Test image upload functionality. Ensure validation works correctly for all fields. Verify that profile changes are reflected throughout the application.",
            "priority": "medium",
            "dependencies": [2, 3],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 5,
            "title": "Application Layout and Navigation",
            "description": "Develop the core application layout, responsive design, and navigation components.",
            "details": "1. Create a responsive layout component with:\n   - Header with logo, navigation, and user menu\n   - Sidebar for main navigation\n   - Main content area\n   - Footer with links and information\n2. Implement mobile-first design with responsive breakpoints\n3. Create navigation components:\n   - MainNav: Primary navigation links\n   - UserMenu: Dropdown with profile and logout options\n   - MobileMenu: Collapsible menu for small screens\n4. Set up React Router with the following routes:\n   - /dashboard: Main dashboard\n   - /pantry: Pantry management\n   - /recipes: Recipe discovery\n   - /shopping-lists: Shopping list management\n   - /assistant: AI cooking assistant\n   - /profile: User profile management\n   - /settings: Application settings\n5. Implement navigation state management\n6. Add loading indicators for route transitions\n7. Create breadcrumb navigation for nested routes\n8. Ensure keyboard navigation accessibility\n9. Add active state styling for current route",
            "testStrategy": "Test responsive layout at various screen sizes. Verify navigation functionality and route transitions. Test keyboard navigation and accessibility. Ensure mobile menu works correctly. Verify that active states are properly applied to current routes.",
            "priority": "high",
            "dependencies": [1, 3],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 6,
            "title": "Pantry Management - Core Functionality",
            "description": "Implement the core pantry management interface for adding, viewing, editing, and deleting ingredients.",
            "details": "1. Create a PantryContext to manage pantry state\n2. Design and implement pantry management components:\n   - PantryList: Main view of pantry items with sorting and filtering\n   - PantryItem: Individual ingredient display component\n   - AddIngredientForm: Form for adding new ingredients\n   - EditIngredientForm: Form for editing existing ingredients\n   - DeleteConfirmation: Confirmation dialog for deleting ingredients\n3. Implement CRUD operations using Supabase client:\n   - fetchPantryItems(): Get user's pantry items\n   - addPantryItem(): Add new ingredient\n   - updatePantryItem(): Update existing ingredient\n   - deletePantryItem(): Remove ingredient\n4. Add form validation using Zod\n5. Implement real-time updates using Supabase Realtime\n6. Create filtering options by category, expiration date, and name\n7. Add sorting options by name, expiration date, and quantity\n8. Implement pagination or infinite scrolling for large pantries\n9. Add loading states and error handling",
            "testStrategy": "Test CRUD operations for pantry items. Verify real-time updates when data changes. Test filtering and sorting functionality. Ensure form validation works correctly. Test pagination/infinite scrolling with a large number of items.",
            "priority": "high",
            "dependencies": [2, 5],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 7,
            "title": "AI-Powered Pantry Input",
            "description": "Implement natural language processing for pantry item input using Supabase Edge Functions and AI.",
            "details": "1. Create a Supabase Edge Function for parsing natural language input:\n   ```typescript\n   // parseIngredients.ts Edge Function\n   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'\n   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'\n   import { Configuration, OpenAIApi } from 'https://esm.sh/openai@3.2.1'\n   \n   serve(async (req) => {\n     const { text } = await req.json()\n     \n     // Initialize OpenAI\n     const configuration = new Configuration({\n       apiKey: Deno.env.get('OPENAI_API_KEY'),\n     })\n     const openai = new OpenAIApi(configuration)\n     \n     try {\n       // Parse ingredients using AI\n       const response = await openai.createCompletion({\n         model: \"text-davinci-003\",\n         prompt: `Parse the following text into structured ingredients with quantities and units:\\n${text}\\nFormat as JSON array with name, quantity, and unit fields.`,\n         max_tokens: 500,\n         temperature: 0.3,\n       })\n       \n       const parsedIngredients = JSON.parse(response.data.choices[0].text.trim())\n       return new Response(JSON.stringify({ ingredients: parsedIngredients }), {\n         headers: { 'Content-Type': 'application/json' },\n         status: 200,\n       })\n     } catch (error) {\n       return new Response(JSON.stringify({ error: error.message }), {\n         headers: { 'Content-Type': 'application/json' },\n         status: 500,\n       })\n     }\n   })\n   ```\n2. Deploy the Edge Function to Supabase\n3. Create a frontend component for natural language input:\n   - NaturalLanguageInput: Textarea with submit button\n   - ParsedIngredientsPreview: Display parsed ingredients before adding to pantry\n   - ConfirmAddition: Confirmation step before adding to pantry\n4. Implement error handling and fallback to manual input\n5. Add loading states during API calls\n6. Create a client-side function to call the Edge Function\n7. Implement batch addition of parsed ingredients to pantry",
            "testStrategy": "Test natural language parsing with various input formats. Verify correct extraction of ingredients, quantities, and units. Test error handling when parsing fails. Ensure batch addition works correctly. Test with edge cases like unusual units or complex descriptions.",
            "priority": "medium",
            "dependencies": [2, 6],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 8,
            "title": "Advanced Pantry Features - Expiration Tracking",
            "description": "Implement expiration date tracking with alerts for expired, critical, warning, and upcoming expirations.",
            "details": "1. Enhance the pantry database schema to include expiration tracking fields\n2. Create utility functions for expiration calculations:\n   - isExpired(date): Check if date is in the past\n   - getExpirationStatus(date): Return status (expired, critical, warning, upcoming, ok)\n   - getDaysUntilExpiration(date): Calculate days remaining\n3. Implement expiration visualization components:\n   - ExpirationBadge: Color-coded badge showing expiration status\n   - ExpirationProgress: Visual indicator of time remaining\n   - ExpirationAlerts: Summary of items requiring attention\n4. Create an expiration dashboard view:\n   - Group items by expiration status\n   - Sort by nearest expiration date\n   - Filter by status\n5. Implement user-configurable thresholds in settings:\n   - Critical threshold (default: 2 days)\n   - Warning threshold (default: 5 days)\n   - Upcoming threshold (default: 10 days)\n6. Add database queries to filter items by expiration status\n7. Implement notification system for expiring items",
            "testStrategy": "Test expiration calculations with various dates. Verify correct classification of items by expiration status. Test threshold configuration and its effect on status calculation. Ensure expiration visualization components display correctly for different statuses. Test filtering and sorting by expiration date.",
            "priority": "medium",
            "dependencies": [6],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 9,
            "title": "Advanced Pantry Features - Intelligent Categorization",
            "description": "Implement AI-powered category suggestions that learn from user behavior for consistent organization.",
            "details": "1. Create a Supabase Edge Function for category suggestions:\n   ```typescript\n   // suggestCategory.ts Edge Function\n   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'\n   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'\n   \n   serve(async (req) => {\n     const { ingredient, userId } = await req.json()\n     \n     // Create Supabase client with service role key\n     const supabase = createClient(\n       Deno.env.get('SUPABASE_URL') ?? '',\n       Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''\n     )\n     \n     try {\n       // Get user's categorization history\n       const { data: userCategories } = await supabase\n         .from('pantry_items')\n         .select('name, category')\n         .eq('user_id', userId)\n       \n       // Get global categorization patterns\n       const { data: globalCategories } = await supabase\n         .from('pantry_items')\n         .select('name, category')\n         .limit(1000)\n       \n       // Simple algorithm to suggest category based on exact or partial matches\n       let suggestedCategory = null\n       \n       // First check user's own categorization\n       const userMatch = userCategories.find(item => \n         item.name.toLowerCase() === ingredient.toLowerCase()\n       )\n       if (userMatch) suggestedCategory = userMatch.category\n       \n       // If no exact match, check partial matches in user data\n       if (!suggestedCategory) {\n         const partialUserMatch = userCategories.find(item => \n           ingredient.toLowerCase().includes(item.name.toLowerCase()) || \n           item.name.toLowerCase().includes(ingredient.toLowerCase())\n         )\n         if (partialUserMatch) suggestedCategory = partialUserMatch.category\n       }\n       \n       // If still no match, check global data\n       if (!suggestedCategory) {\n         const globalMatch = globalCategories.find(item => \n           item.name.toLowerCase() === ingredient.toLowerCase()\n         )\n         if (globalMatch) suggestedCategory = globalMatch.category\n       }\n       \n       // Default categories based on common ingredients\n       const defaultCategories = {\n         'milk': 'Dairy',\n         'cheese': 'Dairy',\n         'yogurt': 'Dairy',\n         'chicken': 'Meat',\n         'beef': 'Meat',\n         'pork': 'Meat',\n         'apple': 'Fruits',\n         'banana': 'Fruits',\n         'orange': 'Fruits',\n         'carrot': 'Vegetables',\n         'onion': 'Vegetables',\n         'potato': 'Vegetables',\n         'rice': 'Grains',\n         'pasta': 'Grains',\n         'bread': 'Bakery',\n         // Add more default mappings\n       }\n       \n       // Check default categories if no match found\n       if (!suggestedCategory) {\n         for (const [key, category] of Object.entries(defaultCategories)) {\n           if (ingredient.toLowerCase().includes(key)) {\n             suggestedCategory = category\n             break\n           }\n         }\n       }\n       \n       // Default to 'Other' if no category found\n       if (!suggestedCategory) suggestedCategory = 'Other'\n       \n       return new Response(JSON.stringify({ category: suggestedCategory }), {\n         headers: { 'Content-Type': 'application/json' },\n         status: 200,\n       })\n     } catch (error) {\n       return new Response(JSON.stringify({ error: error.message }), {\n         headers: { 'Content-Type': 'application/json' },\n         status: 500,\n       })\n     }\n   })\n   ```\n2. Deploy the Edge Function to Supabase\n3. Create frontend components for category management:\n   - CategorySelector: Dropdown with suggested and custom categories\n   - CategoryManager: Interface for managing custom categories\n4. Implement client-side function to call the category suggestion API\n5. Add category management to pantry item forms\n6. Create a category filter for the pantry view\n7. Implement category statistics to show distribution of items\n8. Add ability to bulk recategorize items",
            "testStrategy": "Test category suggestions with various ingredients. Verify that the system learns from user behavior by testing suggestions before and after categorization. Test the fallback to global patterns and default categories. Ensure category management UI works correctly. Test bulk recategorization functionality.",
            "priority": "medium",
            "dependencies": [6, 7],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 10,
            "title": "Advanced Pantry Features - Inventory Level Tracking",
            "description": "Implement low stock alerts based on customizable thresholds per ingredient.",
            "details": "1. Enhance pantry database schema to include inventory tracking fields:\n   - min_quantity: Minimum desired quantity\n   - restock_threshold: Percentage threshold for alerts\n2. Create utility functions for inventory calculations:\n   - isLowStock(item): Check if item is below threshold\n   - getStockLevel(item): Calculate percentage of current vs. minimum\n3. Implement inventory visualization components:\n   - StockLevelIndicator: Visual representation of current stock level\n   - LowStockBadge: Badge for items below threshold\n   - StockSummary: Overview of inventory status\n4. Create inventory management interface:\n   - Set minimum quantities for items\n   - Configure restock thresholds\n   - View low stock items\n5. Implement database queries to filter items by stock level\n6. Add automatic addition of low stock items to shopping list\n7. Create notification system for low stock alerts",
            "testStrategy": "Test inventory level calculations with various quantities and thresholds. Verify correct identification of low stock items. Test threshold configuration. Ensure visualization components display correctly for different stock levels. Test automatic addition to shopping list functionality.",
            "priority": "low",
            "dependencies": [6],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 11,
            "title": "Recipe Management - Core Functionality",
            "description": "Implement the core recipe management interface for browsing, viewing, and bookmarking recipes.",
            "details": "1. Create a RecipeContext to manage recipe state\n2. Design and implement recipe management components:\n   - RecipeList: Grid or list view of available recipes\n   - RecipeCard: Card displaying recipe summary\n   - RecipeDetail: Modal or page showing full recipe details\n   - RecipeFilters: Interface for filtering recipes\n   - BookmarkButton: Toggle for saving favorite recipes\n3. Implement recipe data functions using Supabase client:\n   - fetchRecipes(): Get available recipes\n   - fetchRecipeById(): Get detailed recipe information\n   - toggleBookmark(): Save/unsave recipe as favorite\n4. Create recipe detail view with:\n   - Title, description, and image\n   - Ingredients list with quantities\n   - Step-by-step instructions\n   - Cooking time and difficulty\n   - Tags and categories\n5. Implement filtering by tags, difficulty, and cooking time\n6. Add sorting options by popularity, cooking time, and difficulty\n7. Implement pagination or infinite scrolling for recipe browsing\n8. Add loading states and error handling",
            "testStrategy": "Test recipe browsing with various filters and sorting options. Verify recipe detail view displays all information correctly. Test bookmarking functionality. Ensure pagination/infinite scrolling works with a large number of recipes. Test loading states and error handling.",
            "priority": "high",
            "dependencies": [2, 5],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 12,
            "title": "Recipe Management - 'Can Cook' Discovery",
            "description": "Implement intelligent recipe discovery based on ingredients currently available in the user's pantry.",
            "details": "1. Create a Supabase database function for matching recipes to pantry:\n   ```sql\n   CREATE OR REPLACE FUNCTION match_recipes_to_pantry(user_id UUID)\n   RETURNS TABLE (\n     recipe_id UUID,\n     recipe_title TEXT,\n     match_percentage NUMERIC,\n     missing_ingredients JSONB\n   ) LANGUAGE plpgsql AS $$\n   BEGIN\n     RETURN QUERY\n     WITH user_pantry AS (\n       SELECT name FROM pantry_items WHERE user_id = $1\n     ),\n     recipe_ingredients AS (\n       SELECT \n         r.id,\n         r.title,\n         jsonb_array_elements(r.ingredients) AS ingredient\n       FROM recipes r\n     ),\n     ingredient_matches AS (\n       SELECT\n         ri.id,\n         ri.title,\n         COUNT(DISTINCT p.name) AS matched_count,\n         jsonb_agg(DISTINCT ri.ingredient) FILTER (WHERE p.name IS NULL) AS missing\n       FROM recipe_ingredients ri\n       LEFT JOIN user_pantry p ON \n         p.name ILIKE '%' || ri.ingredient->>'name' || '%' OR\n         ri.ingredient->>'name' ILIKE '%' || p.name || '%'\n       GROUP BY ri.id, ri.title\n     )\n     SELECT\n       im.id,\n       im.title,\n       ROUND((im.matched_count::NUMERIC / jsonb_array_length(r.ingredients)) * 100, 2) AS match_percentage,\n       im.missing\n     FROM ingredient_matches im\n     JOIN recipes r ON im.id = r.id\n     ORDER BY match_percentage DESC;\n   END;\n   $$;\n   ```\n2. Create frontend components for 'Can Cook' discovery:\n   - CanCookView: Main interface showing cookable recipes\n   - MatchPercentageIndicator: Visual display of match percentage\n   - MissingIngredientsList: Display of ingredients not in pantry\n   - CanCookFilters: Filters specific to pantry matching\n3. Implement client-side function to call the database function\n4. Add filtering options:\n   - Minimum match percentage\n   - Maximum number of missing ingredients\n   - Recipe difficulty and cooking time\n5. Create sorting options by match percentage and missing ingredients\n6. Implement quick add to shopping list for missing ingredients\n7. Add loading states and error handling",
            "testStrategy": "Test recipe matching with various pantry contents. Verify correct calculation of match percentages. Test filtering by match percentage and missing ingredients. Ensure quick add to shopping list works correctly. Test with edge cases like empty pantry or recipes with many ingredients.",
            "priority": "high",
            "dependencies": [6, 11],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 13,
            "title": "Shopping List Management",
            "description": "Implement shopping list creation, management, and integration with pantry.",
            "details": "1. Create a ShoppingListContext to manage shopping list state\n2. Design and implement shopping list components:\n   - ShoppingListsOverview: Display of all user shopping lists\n   - ShoppingListDetail: View of items in a specific list\n   - CreateListForm: Form for creating new shopping lists\n   - AddItemForm: Form for adding items to a list\n   - ShoppingListItem: Individual item with purchase toggle\n3. Implement shopping list data functions using Supabase client:\n   - fetchShoppingLists(): Get user's shopping lists\n   - createShoppingList(): Create new list\n   - fetchListItems(): Get items in a specific list\n   - addListItem(): Add item to list\n   - updateListItem(): Update item details\n   - togglePurchased(): Mark item as purchased\n   - deleteListItem(): Remove item from list\n4. Create shopping list management interface:\n   - Create, rename, and delete lists\n   - Add, edit, and remove items\n   - Mark items as purchased\n   - View purchase progress\n5. Implement automatic pantry integration:\n   - Add purchased items to pantry\n   - Update quantities for existing pantry items\n6. Add categorization and sorting of shopping list items\n7. Implement real-time updates using Supabase Realtime\n8. Add loading states and error handling",
            "testStrategy": "Test shopping list CRUD operations. Verify item management functionality. Test marking items as purchased and progress tracking. Ensure automatic pantry integration works correctly. Test real-time updates when data changes. Verify categorization and sorting of items.",
            "priority": "high",
            "dependencies": [2, 5, 6],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 14,
            "title": "Shopping List - Recipe Integration",
            "description": "Implement functionality to add missing ingredients from recipes to shopping lists.",
            "details": "1. Create utility functions for recipe-shopping list integration:\n   - getMissingIngredients(recipeId, userId): Get ingredients not in pantry\n   - formatForShoppingList(ingredients): Format recipe ingredients for shopping list\n   - addRecipeToShoppingList(recipeId, listId, userId): Add missing ingredients to list\n2. Implement UI components:\n   - AddToShoppingListButton: Button in recipe detail view\n   - ShoppingListSelector: Dropdown to select target list\n   - MissingIngredientsPreview: Preview of items to be added\n3. Create a Supabase stored procedure for efficient processing:\n   ```sql\n   CREATE OR REPLACE FUNCTION add_recipe_to_shopping_list(\n     p_recipe_id UUID,\n     p_list_id UUID,\n     p_user_id UUID\n   ) RETURNS SETOF shopping_list_items LANGUAGE plpgsql AS $$\n   DECLARE\n     v_ingredient JSONB;\n     v_item_id UUID;\n   BEGIN\n     -- For each ingredient in the recipe\n     FOR v_ingredient IN \n       SELECT jsonb_array_elements(ingredients) \n       FROM recipes \n       WHERE id = p_recipe_id\n     LOOP\n       -- Check if ingredient exists in pantry\n       IF NOT EXISTS (\n         SELECT 1 FROM pantry_items \n         WHERE user_id = p_user_id \n         AND (name ILIKE '%' || (v_ingredient->>'name') || '%' \n           OR (v_ingredient->>'name') ILIKE '%' || name || '%')\n       ) THEN\n         -- Add to shopping list if not in pantry\n         INSERT INTO shopping_list_items (\n           list_id, name, quantity, unit, category, is_purchased\n         ) VALUES (\n           p_list_id,\n           v_ingredient->>'name',\n           COALESCE((v_ingredient->>'quantity')::NUMERIC, 1),\n           COALESCE(v_ingredient->>'unit', ''),\n           COALESCE(v_ingredient->>'category', 'Other'),\n           FALSE\n         )\n         RETURNING id INTO v_item_id;\n         \n         RETURN QUERY SELECT * FROM shopping_list_items WHERE id = v_item_id;\n       END IF;\n     END LOOP;\n     \n     RETURN;\n   END;\n   $$;\n   ```\n4. Implement client-side function to call the stored procedure\n5. Add ability to select which missing ingredients to add\n6. Create option to add all recipe ingredients regardless of pantry status\n7. Implement duplicate detection and quantity merging\n8. Add loading states and success/error feedback",
            "testStrategy": "Test adding missing ingredients from various recipes. Verify correct identification of missing ingredients. Test with different pantry states. Ensure duplicate detection and quantity merging work correctly. Test the UI flow from recipe to shopping list. Verify loading states and feedback.",
            "priority": "medium",
            "dependencies": [11, 13],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 15,
            "title": "AI Cooking Assistant - Chat Interface",
            "description": "Implement a real-time AI chat interface powered by OpenAI GPT-4.1 API via Supabase Edge Function.",
            "details": "1. Create a Supabase Edge Function for the AI assistant:\n   ```typescript\n   // cookingAssistant.ts Edge Function\n   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'\n   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'\n   import { Configuration, OpenAIApi } from 'https://esm.sh/openai@3.2.1'\n   \n   serve(async (req) => {\n     const { message, userId, conversationHistory } = await req.json()\n     \n     // Initialize OpenAI\n     const configuration = new Configuration({\n       apiKey: Deno.env.get('OPENAI_API_KEY'),\n     })\n     const openai = new OpenAIApi(configuration)\n     \n     // Create Supabase client with service role key\n     const supabase = createClient(\n       Deno.env.get('SUPABASE_URL') ?? '',\n       Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''\n     )\n     \n     try {\n       // Get user profile data\n       const { data: profile } = await supabase\n         .from('users')\n         .select('dietary_restrictions, allergies, skill_level')\n         .eq('id', userId)\n         .single()\n       \n       // Get user's pantry items\n       const { data: pantryItems } = await supabase\n         .from('pantry_items')\n         .select('name, quantity, unit, expiration_date')\n         .eq('user_id', userId)\n       \n       // Format pantry data for the AI\n       const pantryData = pantryItems.map(item => ({\n         name: item.name,\n         quantity: `${item.quantity} ${item.unit}`,\n         expires: item.expiration_date ? new Date(item.expiration_date).toISOString().split('T')[0] : 'unknown'\n       }))\n       \n       // Create system message with context\n       const systemMessage = {\n         role: 'system',\n         content: `You are SmartRecipe's AI cooking assistant. Help the user with cooking advice, recipe suggestions, and ingredient usage.\n         \n         User Profile:\n         - Dietary Restrictions: ${profile.dietary_restrictions || 'None'}\n         - Allergies: ${profile.allergies || 'None'}\n         - Cooking Skill Level: ${profile.skill_level || 'Intermediate'}\n         \n         Current Pantry Contents (${pantryData.length} items):\n         ${JSON.stringify(pantryData, null, 2)}\n         \n         When suggesting recipes, format them as recipe cards using markdown. Focus on recipes the user can make with their current pantry items. Prioritize ingredients that will expire soon. Be helpful, concise, and encouraging.`\n       }\n       \n       // Format conversation history\n       const formattedHistory = conversationHistory.map(msg => ({\n         role: msg.isUser ? 'user' : 'assistant',\n         content: msg.content\n       }))\n       \n       // Add current message\n       const messages = [\n         systemMessage,\n         ...formattedHistory,\n         { role: 'user', content: message }\n       ]\n       \n       // Get response from OpenAI\n       const completion = await openai.createChatCompletion({\n         model: \"gpt-4\", // Use the latest available model\n         messages: messages,\n         max_tokens: 1000,\n         temperature: 0.7,\n       })\n       \n       const reply = completion.data.choices[0].message?.content || 'Sorry, I couldn\\'t generate a response.'\n       \n       return new Response(JSON.stringify({ reply }), {\n         headers: { 'Content-Type': 'application/json' },\n         status: 200,\n       })\n     } catch (error) {\n       return new Response(JSON.stringify({ error: error.message }), {\n         headers: { 'Content-Type': 'application/json' },\n         status: 500,\n       })\n     }\n   })\n   ```\n2. Deploy the Edge Function to Supabase\n3. Create frontend components for the chat interface:\n   - ChatContainer: Main chat interface\n   - MessageList: Display of conversation history\n   - UserMessage: Styling for user messages\n   - AssistantMessage: Styling for AI responses with markdown support\n   - MessageInput: Text input with send button\n   - TypingIndicator: Animation showing AI is responding\n4. Implement chat state management:\n   - Store conversation history\n   - Handle message sending and receiving\n   - Manage loading states\n5. Add markdown rendering for rich text responses\n6. Implement error handling and fallback responses\n7. Create a conversation persistence mechanism\n8. Add ability to clear conversation history",
            "testStrategy": "Test chat interface with various queries. Verify that the AI incorporates user profile and pantry data in responses. Test markdown rendering for recipe suggestions. Ensure conversation history is maintained correctly. Test error handling when the AI service is unavailable. Verify loading states during API calls.",
            "priority": "high",
            "dependencies": [2, 4, 6],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 16,
            "title": "AI Cooking Assistant - Recipe Recommendations",
            "description": "Implement visual recipe recommendations within the AI chat interface.",
            "details": "1. Enhance the AI assistant Edge Function to include recipe recommendations:\n   ```typescript\n   // Add to cookingAssistant.ts Edge Function\n   \n   // Function to search for recipes based on ingredients\n   async function findMatchingRecipes(supabase, ingredients, dietary_restrictions) {\n     // Convert ingredients array to search terms\n     const searchTerms = ingredients.map(i => i.toLowerCase())\n     \n     // Query recipes table\n     let query = supabase\n       .from('recipes')\n       .select('id, title, description, cooking_time, difficulty, image_url, ingredients')\n       .limit(5)\n     \n     // Add filters for dietary restrictions if present\n     if (dietary_restrictions && dietary_restrictions.length > 0) {\n       const restrictions = dietary_restrictions.split(',').map(r => r.trim().toLowerCase())\n       restrictions.forEach(restriction => {\n         query = query.not('tags', 'cs', `{${restriction}}`)\n       })\n     }\n     \n     const { data: recipes } = await query\n     \n     // Score recipes based on ingredient matches\n     return recipes.map(recipe => {\n       const recipeIngredients = recipe.ingredients.map(i => i.name.toLowerCase())\n       const matchCount = searchTerms.filter(term => \n         recipeIngredients.some(ri => ri.includes(term) || term.includes(ri))\n       ).length\n       const matchScore = matchCount / searchTerms.length\n       \n       return {\n         ...recipe,\n         matchScore\n       }\n     }).sort((a, b) => b.matchScore - a.matchScore)\n   }\n   ```\n2. Create components for visual recipe recommendations:\n   - RecipeCard: Visual card with recipe details\n   - RecipeCarousel: Horizontal scrolling container for multiple recipes\n   - RecipeActionButtons: Buttons for viewing details or adding to shopping list\n3. Implement recipe recommendation detection in chat responses\n4. Create a parser to extract recipe suggestions from AI responses\n5. Add ability to view full recipe details from recommendations\n6. Implement quick actions for recommended recipes:\n   - View full details\n   - Add missing ingredients to shopping list\n   - Bookmark recipe\n7. Create a smooth transition between text and visual elements\n8. Add loading states for recipe recommendations",
            "testStrategy": "Test recipe recommendation functionality with various queries. Verify that recommendations are relevant to the conversation and user's pantry. Test the visual display of recipe cards. Ensure quick actions work correctly. Test with edge cases like no matching recipes or dietary restrictions.",
            "priority": "medium",
            "dependencies": [11, 15],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 17,
            "title": "Application Settings",
            "description": "Implement application settings for customizing user experience.",
            "details": "1. Create a SettingsContext to manage application settings\n2. Design and implement settings components:\n   - SettingsForm: Main settings interface\n   - MeasurementSystemSelector: Toggle between metric and imperial\n   - NotificationSettings: Configure notification preferences\n   - ExpirationThresholds: Set thresholds for expiration alerts\n   - InventoryThresholds: Set thresholds for low stock alerts\n   - ThemeSelector: Choose light/dark/system theme\n3. Implement settings data functions using Supabase client:\n   - fetchSettings(): Get user settings\n   - updateSettings(): Update user settings\n4. Create database schema for user settings\n5. Implement settings persistence in Supabase\n6. Add form validation using Zod\n7. Create utility functions to apply settings throughout the application\n8. Implement theme switching functionality\n9. Add loading states and error handling",
            "testStrategy": "Test settings form submission with various inputs. Verify settings persistence in the database. Test application of settings throughout the app (e.g., measurement system changes). Ensure theme switching works correctly. Test form validation for settings inputs.",
            "priority": "low",
            "dependencies": [2, 3, 4],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 18,
            "title": "Error Handling and Fallbacks",
            "description": "Implement robust error handling and fallback mechanisms throughout the application.",
            "details": "1. Create reusable error handling components:\n   - ErrorBoundary: React error boundary component\n   - ErrorFallback: Component to display when errors occur\n   - NetworkErrorMessage: Specific message for network errors\n   - NotFoundView: 404 page for missing resources\n2. Implement error handling utilities:\n   - handleApiError(): Process API errors and display appropriate messages\n   - logError(): Log errors to console or monitoring service\n   - retryOperation(): Retry failed operations with backoff\n3. Add error states to all data fetching operations\n4. Implement graceful degradation for AI features:\n   - Fallback to basic functionality when AI services are unavailable\n   - Clear error messages explaining the issue\n   - Retry mechanisms with appropriate backoff\n5. Create offline detection and messaging\n6. Implement form validation error handling\n7. Add global error notification system\n8. Create error logging to Supabase for monitoring",
            "testStrategy": "Test error handling with various error scenarios (network errors, API failures, etc.). Verify appropriate error messages are displayed. Test retry mechanisms. Ensure graceful degradation of AI features when services are unavailable. Test form validation error handling.",
            "priority": "medium",
            "dependencies": [1, 2, 3, 5, 6, 11, 13, 15],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 19,
            "title": "Accessibility Improvements",
            "description": "Enhance application accessibility to meet WCAG 2.1 AA guidelines.",
            "details": "1. Implement keyboard navigation throughout the application:\n   - Focus management for modals and dialogs\n   - Keyboard shortcuts for common actions\n   - Skip links for main content\n2. Add ARIA attributes to all interactive components:\n   - aria-label for buttons and inputs\n   - aria-describedby for form fields\n   - aria-live regions for dynamic content\n   - aria-expanded for collapsible sections\n3. Ensure proper color contrast throughout the UI:\n   - Test all text against backgrounds\n   - Create high-contrast mode option\n4. Implement screen reader support:\n   - Semantic HTML structure\n   - Alt text for all images\n   - Descriptive link text\n5. Create focus styles for all interactive elements\n6. Add form label associations and error announcements\n7. Implement responsive design for various devices and zoom levels\n8. Create an accessibility statement page",
            "testStrategy": "Test keyboard navigation throughout the application. Verify screen reader compatibility using NVDA or VoiceOver. Check color contrast using automated tools. Test focus management in modals and interactive components. Verify form accessibility and error announcements.",
            "priority": "medium",
            "dependencies": [5, 6, 11, 13, 15],
            "status": "pending",
            "subtasks": []
         },
         {
            "id": 20,
            "title": "Performance Optimization",
            "description": "Optimize application performance for fast page loads and responsive interactions.",
            "details": "1. Implement code splitting and lazy loading:\n   - Split code by route using React.lazy and Suspense\n   - Lazy load heavy components and libraries\n2. Optimize data fetching:\n   - Implement caching strategies\n   - Use pagination and infinite scrolling for large datasets\n   - Add request debouncing and throttling\n3. Optimize rendering performance:\n   - Memoize expensive components with React.memo\n   - Use useCallback and useMemo for performance-critical functions\n   - Implement virtualized lists for large data sets\n4. Add loading skeletons and placeholders:\n   - Create skeleton components for common UI elements\n   - Implement content placeholders during data loading\n5. Optimize images and assets:\n   - Use responsive images with srcset\n   - Implement lazy loading for images\n   - Compress and optimize static assets\n6. Add performance monitoring:\n   - Implement Web Vitals tracking\n   - Monitor and log performance metrics\n7. Optimize database queries:\n   - Add appropriate indexes\n   - Optimize complex queries\n   - Implement query caching where appropriate",
            "testStrategy": "Measure performance metrics before and after optimization using Lighthouse and Web Vitals. Test application performance with large datasets. Verify lazy loading and code splitting functionality. Test loading performance on slow networks. Measure database query performance.",
            "priority": "medium",
            "dependencies": [1, 2, 5, 6, 11, 13, 15],
            "status": "pending",
            "subtasks": []
         }
      ],
      "metadata": {
         "created": "2025-06-29T22:44:32.785Z",
         "updated": "2025-06-29T22:44:32.785Z",
         "description": "Tasks for master context"
      }
   }
}
